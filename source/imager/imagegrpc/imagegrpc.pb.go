// Code generated by protoc-gen-go. DO NOT EDIT.
// source: imagegrpc.proto

/*
Package imagegrpc is a generated protocol buffer package.

It is generated from these files:
	imagegrpc.proto

It has these top-level messages:
	Image
	Images
	NewImageRequest
	NewImageResponse
	RemoveRequest
	RemoveResponse
	ImagesFilter
	ServiceDiscovery
*/
package imagegrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Image struct {
	DocID    string `protobuf:"bytes,1,opt,name=docID" json:"docID,omitempty"`
	PhotoID  string `protobuf:"bytes,2,opt,name=photoID" json:"photoID,omitempty"`
	Original string `protobuf:"bytes,3,opt,name=original" json:"original,omitempty"`
	Thumb    string `protobuf:"bytes,4,opt,name=thumb" json:"thumb,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Image) GetDocID() string {
	if m != nil {
		return m.DocID
	}
	return ""
}

func (m *Image) GetPhotoID() string {
	if m != nil {
		return m.PhotoID
	}
	return ""
}

func (m *Image) GetOriginal() string {
	if m != nil {
		return m.Original
	}
	return ""
}

func (m *Image) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

type Images struct {
	Images []*Image `protobuf:"bytes,1,rep,name=images" json:"images,omitempty"`
}

func (m *Images) Reset()                    { *m = Images{} }
func (m *Images) String() string            { return proto.CompactTextString(m) }
func (*Images) ProtoMessage()               {}
func (*Images) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Images) GetImages() []*Image {
	if m != nil {
		return m.Images
	}
	return nil
}

type NewImageRequest struct {
	DocID    string `protobuf:"bytes,1,opt,name=docID" json:"docID,omitempty"`
	PhotoID  string `protobuf:"bytes,2,opt,name=photoID" json:"photoID,omitempty"`
	Original string `protobuf:"bytes,3,opt,name=original" json:"original,omitempty"`
	Thumb    string `protobuf:"bytes,4,opt,name=thumb" json:"thumb,omitempty"`
}

func (m *NewImageRequest) Reset()                    { *m = NewImageRequest{} }
func (m *NewImageRequest) String() string            { return proto.CompactTextString(m) }
func (*NewImageRequest) ProtoMessage()               {}
func (*NewImageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *NewImageRequest) GetDocID() string {
	if m != nil {
		return m.DocID
	}
	return ""
}

func (m *NewImageRequest) GetPhotoID() string {
	if m != nil {
		return m.PhotoID
	}
	return ""
}

func (m *NewImageRequest) GetOriginal() string {
	if m != nil {
		return m.Original
	}
	return ""
}

func (m *NewImageRequest) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

type NewImageResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *NewImageResponse) Reset()                    { *m = NewImageResponse{} }
func (m *NewImageResponse) String() string            { return proto.CompactTextString(m) }
func (*NewImageResponse) ProtoMessage()               {}
func (*NewImageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *NewImageResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type RemoveRequest struct {
	ColID   string `protobuf:"bytes,1,opt,name=colID" json:"colID,omitempty"`
	ImageID string `protobuf:"bytes,2,opt,name=imageID" json:"imageID,omitempty"`
}

func (m *RemoveRequest) Reset()                    { *m = RemoveRequest{} }
func (m *RemoveRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveRequest) ProtoMessage()               {}
func (*RemoveRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RemoveRequest) GetColID() string {
	if m != nil {
		return m.ColID
	}
	return ""
}

func (m *RemoveRequest) GetImageID() string {
	if m != nil {
		return m.ImageID
	}
	return ""
}

type RemoveResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *RemoveResponse) Reset()                    { *m = RemoveResponse{} }
func (m *RemoveResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveResponse) ProtoMessage()               {}
func (*RemoveResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RemoveResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type ImagesFilter struct {
	ColID string `protobuf:"bytes,1,opt,name=colID" json:"colID,omitempty"`
}

func (m *ImagesFilter) Reset()                    { *m = ImagesFilter{} }
func (m *ImagesFilter) String() string            { return proto.CompactTextString(m) }
func (*ImagesFilter) ProtoMessage()               {}
func (*ImagesFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ImagesFilter) GetColID() string {
	if m != nil {
		return m.ColID
	}
	return ""
}

type ServiceDiscovery struct {
	OrderServiceUri string `protobuf:"bytes,1,opt,name=order_service_uri,json=orderServiceUri" json:"order_service_uri,omitempty"`
}

func (m *ServiceDiscovery) Reset()                    { *m = ServiceDiscovery{} }
func (m *ServiceDiscovery) String() string            { return proto.CompactTextString(m) }
func (*ServiceDiscovery) ProtoMessage()               {}
func (*ServiceDiscovery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ServiceDiscovery) GetOrderServiceUri() string {
	if m != nil {
		return m.OrderServiceUri
	}
	return ""
}

func init() {
	proto.RegisterType((*Image)(nil), "imagegrpc.Image")
	proto.RegisterType((*Images)(nil), "imagegrpc.Images")
	proto.RegisterType((*NewImageRequest)(nil), "imagegrpc.NewImageRequest")
	proto.RegisterType((*NewImageResponse)(nil), "imagegrpc.NewImageResponse")
	proto.RegisterType((*RemoveRequest)(nil), "imagegrpc.RemoveRequest")
	proto.RegisterType((*RemoveResponse)(nil), "imagegrpc.RemoveResponse")
	proto.RegisterType((*ImagesFilter)(nil), "imagegrpc.ImagesFilter")
	proto.RegisterType((*ServiceDiscovery)(nil), "imagegrpc.ServiceDiscovery")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Imager service

type ImagerClient interface {
	// Get all Customers with filter - A server-to-client streaming RPC.
	GetImages(ctx context.Context, in *ImagesFilter, opts ...grpc.CallOption) (Imager_GetImagesClient, error)
	// Create a new Customer - A simple RPC
	DeleteImage(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error)
	AddImage(ctx context.Context, in *NewImageRequest, opts ...grpc.CallOption) (*NewImageResponse, error)
}

type imagerClient struct {
	cc *grpc.ClientConn
}

func NewImagerClient(cc *grpc.ClientConn) ImagerClient {
	return &imagerClient{cc}
}

func (c *imagerClient) GetImages(ctx context.Context, in *ImagesFilter, opts ...grpc.CallOption) (Imager_GetImagesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Imager_serviceDesc.Streams[0], c.cc, "/imagegrpc.Imager/GetImages", opts...)
	if err != nil {
		return nil, err
	}
	x := &imagerGetImagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Imager_GetImagesClient interface {
	Recv() (*Images, error)
	grpc.ClientStream
}

type imagerGetImagesClient struct {
	grpc.ClientStream
}

func (x *imagerGetImagesClient) Recv() (*Images, error) {
	m := new(Images)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *imagerClient) DeleteImage(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error) {
	out := new(RemoveResponse)
	err := grpc.Invoke(ctx, "/imagegrpc.Imager/DeleteImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagerClient) AddImage(ctx context.Context, in *NewImageRequest, opts ...grpc.CallOption) (*NewImageResponse, error) {
	out := new(NewImageResponse)
	err := grpc.Invoke(ctx, "/imagegrpc.Imager/AddImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Imager service

type ImagerServer interface {
	// Get all Customers with filter - A server-to-client streaming RPC.
	GetImages(*ImagesFilter, Imager_GetImagesServer) error
	// Create a new Customer - A simple RPC
	DeleteImage(context.Context, *RemoveRequest) (*RemoveResponse, error)
	AddImage(context.Context, *NewImageRequest) (*NewImageResponse, error)
}

func RegisterImagerServer(s *grpc.Server, srv ImagerServer) {
	s.RegisterService(&_Imager_serviceDesc, srv)
}

func _Imager_GetImages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImagesFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ImagerServer).GetImages(m, &imagerGetImagesServer{stream})
}

type Imager_GetImagesServer interface {
	Send(*Images) error
	grpc.ServerStream
}

type imagerGetImagesServer struct {
	grpc.ServerStream
}

func (x *imagerGetImagesServer) Send(m *Images) error {
	return x.ServerStream.SendMsg(m)
}

func _Imager_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagerServer).DeleteImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imagegrpc.Imager/DeleteImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagerServer).DeleteImage(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imager_AddImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagerServer).AddImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imagegrpc.Imager/AddImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagerServer).AddImage(ctx, req.(*NewImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Imager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imagegrpc.Imager",
	HandlerType: (*ImagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteImage",
			Handler:    _Imager_DeleteImage_Handler,
		},
		{
			MethodName: "AddImage",
			Handler:    _Imager_AddImage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetImages",
			Handler:       _Imager_GetImages_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "imagegrpc.proto",
}

func init() { proto.RegisterFile("imagegrpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 351 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x52, 0x41, 0x4f, 0x32, 0x31,
	0x10, 0x65, 0x3f, 0x3e, 0x10, 0x06, 0x15, 0x68, 0x4c, 0x5c, 0xd7, 0x0b, 0x69, 0x3c, 0x10, 0x62,
	0x88, 0xc1, 0xa3, 0x89, 0xc6, 0x64, 0xd5, 0x70, 0xf1, 0xb0, 0xc6, 0x33, 0x81, 0xee, 0x04, 0x9a,
	0x2c, 0x74, 0x6d, 0xbb, 0x18, 0xff, 0xa6, 0xbf, 0xc8, 0x6c, 0xdb, 0x65, 0x11, 0x49, 0xbc, 0x79,
	0x7c, 0xf3, 0xa6, 0xef, 0xbd, 0xce, 0x0c, 0xb4, 0xf9, 0x72, 0x3a, 0xc7, 0xb9, 0x4c, 0xd9, 0x30,
	0x95, 0x42, 0x0b, 0xd2, 0xdc, 0x14, 0x28, 0x87, 0xda, 0x38, 0x07, 0xe4, 0x04, 0x6a, 0xb1, 0x60,
	0xe3, 0xd0, 0xf7, 0x7a, 0x5e, 0xbf, 0x19, 0x59, 0x40, 0x7c, 0x38, 0x48, 0x17, 0x42, 0x8b, 0x71,
	0xe8, 0xff, 0x33, 0xf5, 0x02, 0x92, 0x00, 0x1a, 0x42, 0xf2, 0x39, 0x5f, 0x4d, 0x13, 0xbf, 0x6a,
	0xa8, 0x0d, 0xce, 0xb5, 0xf4, 0x22, 0x5b, 0xce, 0xfc, 0xff, 0x56, 0xcb, 0x00, 0x3a, 0x82, 0xba,
	0xb1, 0x52, 0xa4, 0x0f, 0x75, 0x93, 0x40, 0xf9, 0x5e, 0xaf, 0xda, 0x6f, 0x8d, 0x3a, 0xc3, 0x32,
	0xa1, 0x69, 0x89, 0x1c, 0x4f, 0x15, 0xb4, 0x9f, 0xf1, 0xdd, 0xd6, 0xf0, 0x2d, 0x43, 0xa5, 0xff,
	0x20, 0xe8, 0x25, 0x74, 0x4a, 0x53, 0x95, 0x8a, 0x95, 0xc2, 0x5c, 0x5f, 0x65, 0x8c, 0xa1, 0x52,
	0xc6, 0xb7, 0x11, 0x15, 0x90, 0xde, 0xc1, 0x51, 0x84, 0x4b, 0xb1, 0xde, 0x0e, 0xc8, 0x44, 0x52,
	0x06, 0x34, 0x20, 0x17, 0x30, 0x7f, 0x2a, 0x03, 0x3a, 0x48, 0x07, 0x70, 0x5c, 0x08, 0xfc, 0x6a,
	0x76, 0x01, 0x87, 0x76, 0x86, 0x8f, 0x3c, 0xd1, 0x28, 0xf7, 0x7b, 0xd1, 0x5b, 0xe8, 0xbc, 0xa0,
	0x5c, 0x73, 0x86, 0x21, 0x57, 0x4c, 0xac, 0x51, 0x7e, 0x90, 0x01, 0x74, 0x85, 0x8c, 0x51, 0x4e,
	0x94, 0x65, 0x26, 0x99, 0xe4, 0xee, 0x55, 0xdb, 0x10, 0xee, 0xc5, 0xab, 0xe4, 0xa3, 0x4f, 0xcf,
	0xad, 0x4a, 0x92, 0x1b, 0x68, 0x3e, 0xa1, 0x76, 0x7b, 0x3b, 0xdd, 0xdd, 0x93, 0x8b, 0x11, 0x74,
	0x7f, 0x10, 0xb4, 0x72, 0xe5, 0x91, 0x10, 0x5a, 0x21, 0x26, 0xa8, 0xd1, 0x9e, 0x98, 0xbf, 0xd5,
	0xf5, 0x6d, 0x64, 0xc1, 0xd9, 0x1e, 0xc6, 0xce, 0x82, 0x56, 0xc8, 0x03, 0x34, 0xee, 0xe3, 0xd8,
	0x4a, 0x04, 0x5b, 0x8d, 0x3b, 0x87, 0x11, 0x9c, 0xef, 0xe5, 0x0a, 0x99, 0x59, 0xdd, 0xdc, 0xfe,
	0xf5, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa9, 0xe4, 0x5f, 0xba, 0x0e, 0x03, 0x00, 0x00,
}
